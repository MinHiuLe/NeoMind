import streamlit as st
import pymongo
import datetime
import bcrypt
import smtplib
from config import configure_api
from chain_setup import create_chain, GEMINI_MODEL
import os
import logging
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

logging.basicConfig(level=logging.INFO)

st.set_page_config(
    page_title="NeoMind",
    page_icon="üêà",
    layout="centered",
    initial_sidebar_state="expanded"
)

# H√†m load file CSS
def local_css(file_name):
    with open(file_name) as f:
        st.markdown(f"<style>{f.read()}</style>", unsafe_allow_html=True)

local_css("styles.css")

# K·∫øt n·ªëi MongoDB (s·ª≠ d·ª•ng st.secrets ƒë·ªÉ qu·∫£n l√Ω th√¥ng tin nh·∫°y c·∫£m)
MONGODB_URI = st.secrets["MONGODB_URI"]
try:
    client = pymongo.MongoClient(MONGODB_URI, serverSelectionTimeoutMS=30000)
    db = client["NeoMind"]
    chat_collection = db["Chat_Session"]
    users_collection = db["Users"]
    client.admin.command('ping')
    logging.info("Connected to MongoDB!")
except Exception as e:
    st.error(f"MongoDB connection failed: {e}")
    st.stop()

# T·∫°o unique index cho email v√† username n·∫øu ch∆∞a t·ªìn t·∫°i
users_collection.create_index("email", unique=True)
users_collection.create_index("username", unique=True)
# H√†m g·ª≠i email c·∫£m ∆°n sau khi ƒëƒÉng k√Ω
def send_thank_you_email(to_email, username):
    # L·∫•y c·∫•u h√¨nh SMTP t·ª´ st.secrets
    smtp_server = st.secrets.get("SMTP_SERVER")
    smtp_port = st.secrets.get("SMTP_PORT")
    email_user = st.secrets.get("EMAIL_USER")
    email_password = st.secrets.get("EMAIL_PASSWORD")
    
    if not all([smtp_server, smtp_port, email_user, email_password]):
        logging.error("SMTP configuration is missing in secrets!")
        return
    
    subject = "Thank You for Registering with NeoMind"
    body = f"""Dear {username},

    Thank you for choosing to join NeoMind. We sincerely appreciate your trust and are delighted to welcome you to our community. At NeoMind, we are committed to providing you with an exceptional experience and innovative solutions that enhance your journey.

    Should you have any questions or require assistance, please do not hesitate to reach out. We are here to support you every step of the way.

    Warm regards,
    HiuLe
    """
    msg = MIMEMultipart()
    msg["From"] = "email_user"
    msg["To"] = to_email
    msg["Subject"] = subject
    msg.attach(MIMEText(body, "plain"))
    
    try:
        server = smtplib.SMTP(smtp_server, int(smtp_port))
        server.starttls()
        server.login(email_user, email_password)
        server.sendmail(email_user, to_email, msg.as_string())
        server.quit()
        logging.info(f"Thank you email sent to {to_email}")
    except Exception as e:
        logging.error(f"Failed to send email: {str(e)}")

#Function to register user
def register_user(email, username, password):
    if users_collection.find_one({"$or": [{"email": email}, {"username": username}]}):
        return False, "Username or Email has already been taken!"
    # Hashed password
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
    user_doc = {
        "email": email,
        "username": username,
        "password": hashed_password,
        "created_at": datetime.datetime.utcnow()
    }
    result = users_collection.insert_one(user_doc)
    if result.inserted_id:
        return True, "Register successfully!"
    return False, "Register failed!"

# H√†m ƒëƒÉng nh·∫≠p ng∆∞·ªùi d√πng
def login_user(username_or_email, password):
    user = users_collection.find_one({"$or": [{"email": username_or_email}, {"username": username_or_email}]})
    if user and bcrypt.checkpw(password.encode('utf-8'), user["password"]):
        return True, user
    return False, "Invalid login information!"

# C√°c h√†m x·ª≠ l√Ω phi√™n chat (ƒë√£ c·∫≠p nh·∫≠t ƒë·ªÉ l∆∞u theo user)
def save_chat_session(title, messages):
    session_doc = {
        "user_id": st.session_state.user["_id"],
        "title": title,
        "messages": messages,
        "created_at": datetime.datetime.utcnow()
    }
    try:
        result = chat_collection.insert_one(session_doc)
        return result.inserted_id
    except Exception as e:
        st.error(f"Failed to save chat session: {str(e)}")
        logging.error(f"Failed to save chat session: {str(e)}")
        return None

def update_chat_session(session_id, messages):
    try:
        chat_collection.update_one({"_id": session_id}, {"$set": {"messages": messages}})
    except Exception as e:
        st.error(f"Failed to update chat session: {str(e)}")
        logging.error(f"Failed to update chat session: {str(e)}")

def load_chat_sessions():
    try:
        return list(chat_collection.find({"user_id": st.session_state.user["_id"]}).sort("created_at", -1))
    except Exception as e:
        st.error(f"Failed to load chat sessions: {str(e)}")
        logging.error(f"Failed to load chat sessions: {str(e)}")
        return []

def delete_chat_session(session_id):
    try:
        chat_collection.delete_one({"_id": session_id})
    except Exception as e:
        st.error(f"Failed to delete chat session: {str(e)}")
        logging.error(f"Failed to delete chat session: {str(e)}")

## N·∫øu ch∆∞a c√≥ bi·∫øn auth_page, m·∫∑c ƒë·ªãnh hi·ªÉn th·ªã trang ƒëƒÉng k√Ω
if "auth_page" not in st.session_state:
    st.session_state.auth_page = "login"

# N·∫øu ng∆∞·ªùi d√πng ch∆∞a ƒëƒÉng nh·∫≠p
if "user" not in st.session_state:
    if st.session_state.auth_page == "register":
        st.subheader("Register")
        with st.form("register_form"):
            reg_email = st.text_input("Email")
            reg_username = st.text_input("Username")
            reg_password = st.text_input("Password", type="password")
            reg_password_confirm = st.text_input("Confirm Password", type="password")
            reg_submit = st.form_submit_button("Register")
        if reg_submit:
            # Ki·ªÉm tra c·∫•u tr√∫c email
            if not reg_email.endswith("@gmail.com"):
                st.error("The email must be in the format ...@gmail.com")
            elif reg_password != reg_password_confirm:
                st.error("Password and Password Confirmation do not match!")
            else:
                # G·ªçi h√†m ƒëƒÉng k√Ω (register_user) ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ph·∫ßn kh√°c
                success, message = register_user(reg_email, reg_username, reg_password)
                if success:
                    st.success(message)
                    # G·ª≠i email c·∫£m ∆°n sau khi ƒëƒÉng k√Ω th√†nh c√¥ng
                    send_thank_you_email(reg_email, reg_username)
                else:
                    st.error(message)
        # N√∫t chuy·ªÉn sang trang ƒëƒÉng nh·∫≠p
        if st.button("Already have an account? Login"):
            st.session_state.auth_page = "login"
            st.rerun()  # C·∫≠p nh·∫≠t l·∫°i trang

    elif st.session_state.auth_page == "login":
        st.subheader("Login")
        with st.form("login_form"):
            login_input = st.text_input("Email or Username")
            login_password = st.text_input("Password", type="password")
            login_submit = st.form_submit_button("Login")
        if login_submit:
            # G·ªçi h√†m ƒëƒÉng nh·∫≠p (login_user) ƒë√£ ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a ·ªü ph·∫ßn kh√°c
            success, user_or_message = login_user(login_input, login_password)
            if success:
                st.session_state.user = user_or_message
                st.success("Register successfully!")
                st.rerun()
            else:
                st.error(user_or_message)
        # N√∫t chuy·ªÉn sang trang ƒëƒÉng k√Ω
        if st.button("Don't have an account yet? Register"):
            st.session_state.auth_page = "register"
            st.rerun()
    st.stop()

# Sau khi ƒëƒÉng nh·∫≠p, hi·ªÉn th·ªã th√¥ng tin ng∆∞·ªùi d√πng
st.sidebar.write(f"Hello, {st.session_state.user['username']}")

# Ph·∫ßn chat c·ªßa ·ª©ng d·ª•ng
st.title("üêà NeoMind: AI Research")

if "api_key" not in st.session_state:
    st.session_state.api_key = st.secrets.get("GEMINI_API_KEY", "")

if "messages" not in st.session_state:
    st.session_state.messages = [{"role": "assistant", "content": "How can I help you today?"}]

if "current_session_id" not in st.session_state:
    st.session_state.current_session_id = None

with st.sidebar:
    st.header("üêà NeoMind")
    if st.button("üí¨ New Chat", key="new_chat"):
        default_msg = [{"role": "assistant", "content": "How can I help you today?"}]
        if st.session_state.messages != default_msg:
            first_user_msg = next((msg["content"] for msg in st.session_state.messages if msg["role"] == "user"), None)
            title = first_user_msg if first_user_msg else "New Chat"
            if st.session_state.current_session_id is not None:
                update_chat_session(st.session_state.current_session_id, st.session_state.messages)
            else:
                new_id = save_chat_session(title, st.session_state.messages)
                st.session_state.current_session_id = new_id
        st.session_state.messages = [{"role": "assistant", "content": "How can I help you today?"}]
        st.session_state.current_session_id = None

    st.subheader("Saved Sessions")
    sessions = load_chat_sessions()
    max_title_length = 25
    for session in sessions:
        title = session.get("title", "New Chat")
        if len(title) > max_title_length:
            title = title[:max_title_length] + "..."
        col1, col2 = st.columns([3, 1])
        if col1.button(title, key=str(session["_id"])):
            st.session_state.messages = session["messages"]
            st.session_state.current_session_id = session["_id"]
        if col2.button("‚ùå", key="delete_" + str(session["_id"])):
            delete_chat_session(session["_id"])
            st.rerun()

if st.session_state.api_key:
    try:
        configure_api(st.session_state.api_key)
        if "chain" not in st.session_state:
            st.session_state.chain = create_chain(st.session_state.api_key)

        for msg in st.session_state.messages:
            with st.chat_message(msg["role"]):
                st.markdown(f'<div class="custom-card new-message">{msg["content"]}</div>', unsafe_allow_html=True)

        if prompt := st.chat_input("üí¨ Ask me anything..."):
            st.session_state.messages.append({"role": "user", "content": prompt})
            st.chat_message("user").write(prompt)
            
            with st.spinner("üêà NeoMind Processing..."):
                try:
                    response = st.session_state.chain.run(question=prompt)
                    st.session_state.messages.append({"role": "assistant", "content": response})
                    st.chat_message("assistant").write(response)
                except Exception as e:
                    st.error(f"‚ö†Ô∏è Error: {str(e)}")
                    logging.error(f"Error when connecting to API: {str(e)}")
                    st.session_state.messages.pop()
            
            # Sau m·ªói l∆∞·ª£t chat, t·ª± ƒë·ªông l∆∞u phi√™n chat
            if st.session_state.current_session_id is not None:
                update_chat_session(st.session_state.current_session_id, st.session_state.messages)
            else:
                first_user_msg = next((msg["content"] for msg in st.session_state.messages if msg["role"] == "user"), None)
                title = first_user_msg if first_user_msg else "New Chat"
                new_id = save_chat_session(title, st.session_state.messages)
                st.session_state.current_session_id = new_id

    except Exception as e:
        st.error(f"‚ùå Configuration Error: {str(e)}")
        logging.error(f"Configuration Error: {str(e)}")
else:
    st.warning("üîë Please enter your Gemini API Key in the sidebar to start")
